// This file is generated by kconfig_compiler from settings.kcfg.
// All changes you do to this file will be lost.
#ifndef SETTINGS_H
#define SETTINGS_H

#include <kconfigskeleton.h>
#include <kdebug.h>

#include <kglobalsettings.h>
class Settings : public KConfigSkeleton
{
  public:

    static Settings *self();
    ~Settings();

    /**
      Set Font used for the scrolling text
    */
    static
    void setFont( const QFont & v )
    {
      if (!self()->isImmutable( QString::fromLatin1( "Font" ) ))
        self()->mFont = v;
    }

    /**
      Get Font used for the scrolling text
    */
    static
    QFont font()
    {
      return self()->mFont;
    }

    /**
      Set The color used for the scrolling text
    */
    static
    void setColor( const QColor & v )
    {
      if (!self()->isImmutable( QString::fromLatin1( "Color" ) ))
        self()->mColor = v;
    }

    /**
      Get The color used for the scrolling text
    */
    static
    QColor color()
    {
      return self()->mColor;
    }

    /**
      Set Whether news which have been read should be shown in the scroller again
    */
    static
    void setHideReadArticles( bool v )
    {
      if (!self()->isImmutable( QString::fromLatin1( "HideReadArticles" ) ))
        self()->mHideReadArticles = v;
    }

    /**
      Get Whether news which have been read should be shown in the scroller again
    */
    static
    bool hideReadArticles()
    {
      return self()->mHideReadArticles;
    }

    /**
      Set Paints a background like the knewsticker in kde 3.x did.
    */
    static
    void setUIStyle( bool v )
    {
      if (!self()->isImmutable( QString::fromLatin1( "UIStyle" ) ))
        self()->mUIStyle = v;
    }

    /**
      Get Paints a background like the knewsticker in kde 3.x did.
    */
    static
    bool uIStyle()
    {
      return self()->mUIStyle;
    }

    /**
      Set Determines if the scrolling is done horizontally or vertically
    */
    static
    void setScrollHorizontal( bool v )
    {
      if (!self()->isImmutable( QString::fromLatin1( "ScrollHorizontal" ) ))
        self()->mScrollHorizontal = v;
    }

    /**
      Get Determines if the scrolling is done horizontally or vertically
    */
    static
    bool scrollHorizontal()
    {
      return self()->mScrollHorizontal;
    }

    /**
      Set How many times per second the scrolling text should be redrawn.
    */
    static
    void setScrollingSpeed( uint v )
    {
      if (!self()->isImmutable( QString::fromLatin1( "ScrollingSpeed" ) ))
        self()->mScrollingSpeed = v;
    }

    /**
      Get How many times per second the scrolling text should be redrawn.
    */
    static
    uint scrollingSpeed()
    {
      return self()->mScrollingSpeed;
    }

    /**
      Set How many seconds the message is displayed when horizontal scrolling is enabled
    */
    static
    void setMessageDelay( double v )
    {
      if (!self()->isImmutable( QString::fromLatin1( "MessageDelay" ) ))
        self()->mMessageDelay = v;
    }

    /**
      Get How many seconds the message is displayed when horizontal scrolling is enabled
    */
    static
    double messageDelay()
    {
      return self()->mMessageDelay;
    }

    /**
      Set How many pixels the scrolling text moves per redraw
    */
    static
    void setScrollingDistance( uint v )
    {
      if (!self()->isImmutable( QString::fromLatin1( "ScrollingDistance" ) ))
        self()->mScrollingDistance = v;
    }

    /**
      Get How many pixels the scrolling text moves per redraw
    */
    static
    uint scrollingDistance()
    {
      return self()->mScrollingDistance;
    }

    /**
      Set List of URLs to RSS feeds which should be shown
    */
    static
    void setFeedUrls( const QStringList & v )
    {
      if (!self()->isImmutable( QString::fromLatin1( "FeedUrls" ) ))
        self()->mFeedUrls = v;
    }

    /**
      Get List of URLs to RSS feeds which should be shown
    */
    static
    QStringList feedUrls()
    {
      return self()->mFeedUrls;
    }

    /**
      Set List of maximum displayed items per RSS feed
    */
    static
    void setFeedMaxItems( const QList<int> & v )
    {
      if (!self()->isImmutable( QString::fromLatin1( "FeedMaxItems" ) ))
        self()->mFeedMaxItems = v;
    }

    /**
      Get List of maximum displayed items per RSS feed
    */
    static
    QList<int> feedMaxItems()
    {
      return self()->mFeedMaxItems;
    }

    /**
      Set The update interval (in minutes) defining how often the feeds are updated
    */
    static
    void setUpdateInterval( uint v )
    {
      if (!self()->isImmutable( QString::fromLatin1( "UpdateInterval" ) ))
        self()->mUpdateInterval = v;
    }

    /**
      Get The update interval (in minutes) defining how often the feeds are updated
    */
    static
    uint updateInterval()
    {
      return self()->mUpdateInterval;
    }

    /**
      Set Determines how much items are collected per feed. 0 means unlimited
    */
    static
    void setMaxNewsItems( uint v )
    {
      if (!self()->isImmutable( QString::fromLatin1( "MaxNewsItems" ) ))
        self()->mMaxNewsItems = v;
    }

    /**
      Get Determines how much items are collected per feed. 0 means unlimited
    */
    static
    uint maxNewsItems()
    {
      return self()->mMaxNewsItems;
    }

    /**
      Set List of rules to filter news items
    */
    static
    void setFilterEntries( const QStringList & v )
    {
      if (!self()->isImmutable( QString::fromLatin1( "FilterEntries" ) ))
        self()->mFilterEntries = v;
    }

    /**
      Get List of rules to filter news items
    */
    static
    QStringList filterEntries()
    {
      return self()->mFilterEntries;
    }

  protected:
    Settings();
    friend class SettingsHelper;


    // Visual
    QFont mFont;
    QColor mColor;
    bool mHideReadArticles;
    bool mUIStyle;
    bool mScrollHorizontal;
    uint mScrollingSpeed;
    double mMessageDelay;
    uint mScrollingDistance;

    // FeedLoading
    QStringList mFeedUrls;
    QList<int> mFeedMaxItems;
    uint mUpdateInterval;
    uint mMaxNewsItems;

    // FilterProperties
    QStringList mFilterEntries;

  private:
};

#endif

